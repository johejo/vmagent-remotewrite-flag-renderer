// SPDX-License-Identifier: Apache-2.0

// Generate struct from vmagent help
// Usage: /path/to/vmagent-prod -h | go run ./internal/vmagentconfiggen > ./vmagent_gen.go

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"regexp"
	"strings"
)

var re = regexp.MustCompile(`\s+-(?P<name>.*)\sarray`)

type mapflag struct {
	opened map[string]struct{}
	closed map[string]struct{}
}

func newMapFlag() *mapflag {
	return &mapflag{
		opened: make(map[string]struct{}),
		closed: make(map[string]struct{}),
	}
}

func (m *mapflag) SetOpened(name string) {
	m.opened[name] = struct{}{}
}

func (m mapflag) IsOpened(name string) bool {
	_, ok := m.opened[name]
	return ok
}
func (m *mapflag) SetClosed(name string) {
	m.closed[name] = struct{}{}
}

func (m mapflag) IsClosed(name string) bool {
	_, ok := m.closed[name]
	return ok
}

func main() {
	s := bufio.NewScanner(os.Stdin)
	b := new(bytes.Buffer)
	p(b, "// Code generated by internal/vmagentconfiggen DO NOT EDIT.")
	p(b, "package main")
	p(b, "type vmagentRemoteWriteConfig struct {")
	m := newMapFlag()
	var prev string
	for s.Scan() {
		line := s.Text()
		if !re.MatchString(line) {
			continue
		}
		matches := re.FindStringSubmatch(line)
		if len(matches) == 0 {
			continue
		}
		name := matches[re.SubexpIndex("name")]
		if !strings.Contains(name, "remoteWrite") {
			continue
		}
		part := strings.Split(name, ".")

		if prev != "" && prev != part[1] {
			if !m.IsClosed(prev) {
				p(b, "} `json:\"%s\" yaml:\"%s\"`", prev, prev)
				m.SetClosed(prev)
			}
		}
		switch len(part) {
		case 2: // remoteWrite.${foo}
			p(b, "VMAgent_%s string `json:\"%s\" yaml:\"%s\" vmagent-flag:\"%s.%s\"`", part[1], part[1], part[1], part[0], part[1])
			m.SetClosed(part[1])
			prev = part[1]
		case 3: // remoteWrite.${foo}.${bar}
			if !m.IsOpened(part[1]) {
				p(b, "VMAgent_%s struct {", part[1])
				m.SetOpened(part[1])
			}
			p(b, "VMAgent_%s string `json:\"%s\" yaml:\"%s\" vmagent-flag:\"%s.%s.%s\"`", part[2], part[2], part[2], part[0], part[1], part[2])
			prev = part[1]
		}
	}
	p(b, "}")
	bb, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	os.Stdout.Write(bb)
}

func p(b *bytes.Buffer, format string, args ...any) {
	fmt.Fprintf(b, format+"\n", args...)
}
